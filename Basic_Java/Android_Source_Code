1.ApplicationThread是什么线程，属于哪个进程，作用是什么
它不是线程类，而是运行在应用进程中的一个Binder线程里，作为应用程序的Binder服务端，接收AMS的指令的，


2.ART的长处：在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用


Java层的Binder只是一个封装，主要是用来调用Native层的Binder，这两个都是在用户空间，所以Native层也不能将数据传输到其他进程，它需要通过系统调用，把数据复制到内核空间，内核空间会找到对应的进程并把数据发给它，这样数据就到了目标进程的Native层，它通过JNI调用到Java Binder层的transact，这样应用层就能根据cmd处理data了。Binder是IPC的底层通讯架构，我们不需要知道细节，应用层使用AIDL就可以只关心业务逻辑就能实现IPC。


ActivityThread 用来在应用进程的主线程处理AMS交给的任务，主要和四大组件相关，以Activity的生命周期为例：
1.activity启动的核心实现流程：performLaunchActivity
	为activity创建context
	ContextImpl appContext = createBaseContextForActivity(r);
	实例化activity
	activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);
	//创建Manifest中指定的Application，同时createAppContext，还不知道和createBaseContextForActivity区别。最后调用Application的onCreate
	Application app = r.packageInfo.makeApplication(false, mInstrumentation);
	//实列化的act其实啥都不能干，就是普通的类，直到attach方法赋予其众多功能，关注r.token：来自WMS的令牌
	activity.attach（。。。）
	attach方法中实现了和Window的关联，这样act就能处理和Window相关的回调
	//PhoneWindow 作为View的顶级容器，能够提供UI所需的基本模板
		 mWindow = new PhoneWindow(this, window, activityConfigCallback);
	     mWindow.setWindowControllerCallback(this);
	     mWindow.setCallback(this);
	     mWindow.setOnWindowDismissedCallback(this);
	     //看下面窗口相关的分析
	     mWindow.setWindowManager（。。。）
	
	//设置主题，没有就用应用的主题
	activity.setTheme(theme);

	 完成和Window的关联后就 开始了act 的onCreate回调，act有很多子类，每个子类都有对应的初始化，比如Fragment、Lifecycle相关的
	 if (r.isPersistable()) {
		mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
    } else {
        mInstrumentation.callActivityOnCreate(activity, r.state);
    }
    //看下面具体分析
    onCreate是一个重要的回调，其中setContentView将xml解析成控件树，但仅停留在描述阶段，没有测量、布局和绘制，只是准备工作

2.handleStartActivity，内容相对少，调用onstart，分发事件通知Lifecycle的监听者
3.handleResumeActivity 这是重要的一步，在performResumeActivity后，DecorView，ViewRootImpl开始关联
	View decor = r.window.getDecorView();
	wm.addView(decor, l);
	addView方法最后实列化了ViewRootImpl，实列化完成两件重要的事
		//获取WindowSession用来给WMS发消息，WindowSession是进程单列
	    mWindowSession = WindowManagerGlobal.getWindowSession();
	    //创建IWindow用来接收WMS的消息，现在还是解不了，因为WMS还不知道这个服务端，需要我们发送
        mWindow = new W(this);
    接下ViewRootImpl的setView方法，将应用所需的窗口大小、我们的IWindow发给WMS，这样WMS知道了我们的窗口大小，也有了和应用通讯的桥梁
    除此之外，还安排了Traversals，开始了measure、layout、draw操作，让我们的内容显示出来
    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,
                            mTempInsets);

4.handlePauseActivity、handleStopActivity 工作内容较少，主要是分发事件 更新状态
6.handleDestroyActivity 销毁DecorView，通知WMS释放资源


WindowManager服务的注册，在SystemServiceRegistry里面对大量的系统服务进行注册，其中就有WindowManager的实现类WindowManagerImpl
registerService(Context.WINDOW_SERVICE, WindowManager.class,
                new CachedServiceFetcher<WindowManager>() {
            @Override
            public WindowManager createService(ContextImpl ctx) {
                return new WindowManagerImpl(ctx);
            }});

下面这个方法获取的就是WindowManagerImpl
WindowManager windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
在activity的attach方法中，给phoneWindow设置了WindowManager，如下
 mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
从方法上看，好像是把系统服务的WindowManagerImpl作为了WindowManager，其实内部实现不是这样的

public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) {
        mAppToken = appToken;
       	...
       	//这个createLocalWindowManager为Activity创建的的WindowManager也是WindowManagerImpl类型，就是mParentWindow被赋值成了this：PhoneWindow
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    }

总的来说
context.getSystemService(Context.WINDOW_SERVICE)=WindowManagerImpl(ctx)
activity.getWindowManager=WindowManagerImpl(ctx,phoneWindow)


###setContentView
在我们自定的Activity中，当OnCreate回调结束后，通常都有一个setContentView方法来加载我们的控件树，不追看源码还是为是Acivity处理的，其实是交给PhoneWindow处理的
        getWindow().setContentView(layoutResID);
来看看PhoneWindow中具体处理，先是installDecor
	1.生成DecorView：this就是PhoneWindow，DecorView是定制的FrameLayout，是控件树的顶级父容器
new DecorView(context, featureId, this, getAttributes())
	2.generateLayout，这一步的工作主要是根据设置的Feature来选一个layout模板，比如R.layout.screen_swipe_dismiss用的是SwipeDismissLayout，我们常用的R.layout.screen_simple就是一个LinearLayout，由一个给ActionBar占位的ViewStub和一个FrameLayout组成，这些layout模板的共同点是有一个id为@android:id/content的View Group，它是用来作为我们ContentView的父View，即ContentParent
选好layout模板就开始布局填充，把框架先搭起来
        mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
        具体实现，root为null
        final View root = inflater.inflate(layoutResource, null);
        检查模板是否真的有id为@android:id/content的View Group，没有就抛异常
        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);

完成模板后，把我们自定义的xml描述的变成真正的控件树，mContentParent就是上面的root ，View填充的细节暂忽略       
 mLayoutInflater.inflate(layoutResID, mContentParent);


####ViewRootImpl
构造函数的初始化
1.创建WindowSession给WMS发消息
2.创建IWindow接收WMS消息
3.mWinFrame 窗口的位置和大小和WMS中的WindowState.Frame保持一致，mWidth、mHeight记录窗口在ViewRootImpl的尺寸
4.AttachInfo(mWindowSession, mWindow, display, ViewRootImpl, mHandler, ViewRootImpl,context)，
	A set of information given to a view when it is attached to its parent window.每个View都有它所依附的父窗口的大量信息
4.IWindow中接收到的消息在Binder线程中，有些和重绘相关的消息，需要通过mHandler发到主线程执行
5.mChoreographer 根据VSYNC信号来安排下一次遍历，具有周期性

来自WMS的窗口属性变化，View树的布局变化、重绘都会导致控件树的遍历
ViewRootImpl的遍历：
预测量：使用WindowSize作为最大尺寸来测量控件树
，请求WMS来计算Activity窗口的大小，如果预测量结果和WMS计算的窗口大小不一致，需要按照WMS的要求重新布局窗口大小，并按照新窗口大小重新测量控件，然后布局控件树、绘制控件树


消息机制
1.Looper的初始化：Loop.prepare()
  1.1首先判断当前线程是否已经关联了Looper，因为每个线程只能关联一个Looper，通过ThreadLocal实现
  1.2 实列化Looper,主要是实列化MeseageQueue，如果looper属于主线程则MeseageQueue不可以退出
  1.3 开始运转 Looper.loop()
	判断当前线程是否有looper，有的话获取其绑定的MessageQueue,开始无限循环模式提取 MessageQueue中的msg，把msg发给目标Handler
Looper的的主要职责是对MQ的管理：初始化、轮询、退出

2.MessageQueue Java层是一个包装，核心功能在native，当Looper开始运作，真正在工作的是MQ，它使用链表来维持一个以时间排序的消息队列		
	MQ的主要工作1：从队头取出一条消息载体Message
			//如果消息队列为空就阻塞 处于休眠等待状态 节省CPU  这块需要深究 //Java层的消息队列是否和Navtive层一致 如果不一致 这个等待的好像是Native层的
		//在从消息队列取出头部消息之前，先调用一个本地方法 当没有MSG时它是阻塞的
			nativePollOnce(ptr, nextPollTimeoutMillis);
            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
               // 对于取出来的MSG，首先要判断它是不是一个barrier（特征：handler=null）用来阻塞同步消息的，应用程序很少使用这种异步MSG，系统使用场景?->ViewRootImpl。
                if (msg != null && msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    如果是的话找到后面第一条异步MSG（特征：msg.isAsynchronous()）
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }
                //msg可能是异步消息，那么prevMsg != null，如果是同步消息，就是队列第一个，那么prevMsg == null
                if (msg != null) {
                    if (now < msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        //剔除和队列的关系
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    //找不到异步消息，MQ会继续阻塞而不会挑一个同步消息执行
                    nextPollTimeoutMillis = -1;
                }
     如果队列中没有消息或者有消息但没有到执行时间，会给IdleHandler一次回调的机会，也就是在队列不繁忙的时候执行一些操作

     MQ的主要工作2:向消息队列插入一条MSG
     		//队头
    		Message p = mMessages;
            boolean needWake;
            //直接插到头部
            if (p == null || when == 0 || when < p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                //判断唤醒队列的条件：已阻塞 消息头是barrier，插入的消息是异步的
                上面的分析可知，barrier会阻塞同步消息，如果是异步消息，需要唤醒MQ来处理这个异步消息
                needWake = mBlocked && p.target == null && msg.isAsynchronous();
                Message prev;
                //为MSG找到要插入的位置
                for (;;) {
                    prev = p;
                    p = p.next;
                    p==null 插入队尾，一种是队列中只有一个消息头，另外一种情况是msg的when大于队列中所有when，要插到队尾
                    when<p.when MQ维护的链表是按msg的时间升序排列，如果找到队列中第一个when比msg的when还大的msg就退出
                    if (p == null || when < p.when) {
                        break;
                    }
                    //如果之前判断需要唤醒，现在发现异步消息之前还有其他异步消息，说明已经唤醒过 不需要再唤醒
                    if (needWake && p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                //把msg插入到找到的位置  符合时间升序排列
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }


	应用程序很少使用的功能：插入同步屏障	
	private int postSyncBarrier(long when) {
        // Enqueue a new sync barrier token.
        // We don't need to wake the queue because the purpose of a barrier is to stall it.
        synchronized (this) {
            final int token = mNextBarrierToken++;
            final Message msg = Message.obtain();
            //msg的target为null，这是我们识别同步屏障的特征
            msg.markInUse();
            msg.when = when;
            msg.arg1 = token;

            Message prev = null;
            Message p = mMessages;
            //同样要给同步屏障msg找到需要插入的位置，如果when为0 明显插到队头
            if (when != 0) {
            	//p.when<=when 表示链表中的p比要插入的msg时间小，msg需要往后找位置
                while (p != null && p.when <= when) {
                    prev = p;
                    p = p.next;
                }
            }
            //找到了能插入的位置 
            if (prev != null) { // invariant: p == prev.next
                msg.next = p;
                prev.next = msg;
            } else {
            //prev==null 说明插在队头 when比队列中时间都小
                msg.next = p;
                mMessages = msg;
            }
            return token;
        }
    }
	
	移除同步屏障
	public void removeSyncBarrier(int token) {
        // Remove a sync barrier token from the queue.
        // If the queue is no longer stalled by a barrier then wake it.
        synchronized (this) {
            Message prev = null;
            Message p = mMessages;
            //一般来说同步屏障就在队头，如果在队中说明还没起屏障作用就要把它移除
            while (p != null && (p.target != null || p.arg1 != token)) {
                prev = p;
                p = p.next;
            }
            if (p == null) {
                throw new IllegalStateException("The specified message queue synchronization "
                        + " barrier token has not been posted or has already been removed.");
            }
            final boolean needWake;
            //如果prev！=null说明在队中，同步屏障还没起作用 没有阻塞队列 剔除p 不需要唤醒
            if (prev != null) {
                prev.next = p.next;
                needWake = false;
            } else {
            	//同步屏障在队头，将队头指向同步屏障msg的下一个 即移除barrier
                mMessages = p.next;
                //为啥下一个msg为空需要唤醒队列，不解？？
                needWake = mMessages == null || mMessages.target != null;
            }
            p.recycleUnchecked();

            // If the loop is quitting then it is already awake.
            // We can assume mPtr != 0 when mQuitting is false.
            if (needWake && !mQuitting) {
                nativeWake(mPtr);
            }
        }
    }

    MQ移除消息：可根据handler、what 、obj等参数移除msg，一个handler只能移除自己插入的消息
    //开始我还奇怪 为什么分两个循环  一个循环应该就能完成 原因在于会丢掉队头消息，
    void removeMessages(Handler h, int what, Object object) {
        if (h == null) {
            return;
        }

        synchronized (this) {
            Message p = mMessages;
    		当从队头开始就符合条件时，msg会被移除 这样我们会丢失队头，所以在回收的同时也要重新设置队头
            // Remove all messages at front.
            while (p != null && p.target == h && p.what == what
                   && (object == null || p.obj == object)) {
                Message n = p.next;
                //mMessages设置新队头
                mMessages = n;
                p.recycleUnchecked();
                p = n;
            }

            // Remove all messages after front.
            //在确定新队头后 回收后面符合条件的msg 并从队列移除
            while (p != null) {
                Message n = p.next;
                if (n != null) {
                    if (n.target == h && n.what == what
                        && (object == null || n.obj == object)) {
                        Message nn = n.next;
                        n.recycleUnchecked();
                        p.next = nn;
                        continue;
                    }
                }
                p = n;
            }
        }
    }

    MQ的退出：主线程的MQ是不可以退出的，能退出的分安全退出和不安全退出，不安全退出相对简单，不管三七二十一把队列的所有msg回收掉
    //主要看看安全退出 策略是把队列中比当前时间大的msg回收掉
    private void removeAllFutureMessagesLocked() {
        final long now = SystemClock.uptimeMillis();
        Message p = mMessages;
        if (p != null) {
        	//如果队头的时间都比now大，说明全都可以移除
            if (p.when > now) {
                removeAllMessagesLocked();
            } else {
            	//否则找到比now大的第一个msg，也就是n
                Message n;
                for (;;) {
                    n = p.next;
                    if (n == null) {
                        return;
                    }
                    if (n.when > now) {
                        break;
                    }
                    p = n;
                }
                //p的后面就是n，从n开始都是要移除的 断开链接
                p.next = null;
                //从n开始回收
                do {
                    p = n;
                    n = p.next;
                    p.recycleUnchecked();
                } while (n != null);
            }
        }
    }

MQ的作用主要就是压入msg，取出msg，移除msg，判断msg是否存在等


3.Handler用来安排和执行msg，Looper绑定唯一Thread，Handler绑定唯一的Looper，所以如果你希望msg在哪个Thread执行，
使用和那个线程绑定的Handler发送消息即可

Handler提供的插入、查询、删除msg方法，最终都是由MQ实现的 如插入
 private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
            long uptimeMillis) {
        //loop取出来的msg最后还是交给target处理，即谁插入的谁处理
        msg.target = this;
        msg.workSourceUid = ThreadLocalWorkSource.getUid();
        //一般队列是同步的 不知道源码是否有asyn使用场景
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }

    除此之外，Handler中有一个特殊的方法，它能阻塞调用者的线程，直到handler所在的线程把这个msg执行完毕
    public final boolean runWithScissors(@NonNull Runnable r, long timeout) {
        if (r == null) {
            throw new IllegalArgumentException("runnable must not be null");
        }
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout must be non-negative");
        }

        //如果调用线程和Handler所在线程是同一个，直接执行后返回
        if (Looper.myLooper() == mLooper) {
            r.run();
            return true;
        }
        //否则使用BlockingRunnable
        BlockingRunnable br = new BlockingRunnable(r);
        return br.postAndWait(this, timeout);
    }

		主要看BlockingRunnable的实现
     private static final class BlockingRunnable implements Runnable {
        private final Runnable mTask;
        private boolean mDone;

        public BlockingRunnable(Runnable task) {
            mTask = task;
        }

        @Override
        public void run() {
        	//被handler执行了 最后设置mDone=true 唤醒等待线程 跳出无限循环结束postAndWait，也就解除了阻塞
        	//为什么looper退出的时候最好使用安全模式，从上面的分析可知，安全模式只移除quit时刻之后的msg，这样能
        	保证BlockingRunnable这样的msg能执行，阻塞也能解除。如果是非安全模式，所有msg被移除，包括这个BlockingRunnable，
        	那么此run方法就永远不会执行，此线程也就有可能一直阻塞
            try {
                mTask.run();
            } finally {
                synchronized (this) {
                    mDone = true;
                    notifyAll();
                }
            }
        }

        public boolean postAndWait(Handler handler, long timeout) {
        	//先发到handler所在线程的MQ中，等待执行 如果MQ已退出，压入失败 返回false
            if (!handler.post(this)) {
                return false;
            }
            //阻塞当前线程
            synchronized (this) {
                if (timeout > 0) {
                	//设置了超时等待
                    final long expirationTime = SystemClock.uptimeMillis() + timeout;
                    while (!mDone) {
                        long delay = expirationTime - SystemClock.uptimeMillis();
                        //没等待之前肯定大于0，等待苏醒后先检查mDone，如果还是false，看看有没有超时，如果超了就不等待了
                        if (delay <= 0) {
                            return false; // timeout
                        }
                        //进入等待状态，等待指定的delay后苏醒检查mDone，有可能delay还没到就被唤醒
                        try {
                            wait(delay);
                        } catch (InterruptedException ex) {
                        }
                    }
                } else {
                //没有设置超时 无限等待
                    while (!mDone) {
                        try {
                            wait();
                        } catch (InterruptedException ex) {
                        }
                    }
                }
            }
            return true;
        }
    }