1.在微软官网下载SQL Server Express 版本安装版
2.直接双击安装，选择基本安装和路径，省去自定义的配置直接安装成功。
3.下载安装Sql Served manager Studio
4.参考官方的使用教城 https://docs.microsoft.com/zh-cn/sql/ssms/tutorials/connect-query-sql-server?view=sql-server-2017

配置文件如下
Server=localhost\SQLEXPRESS;Database=master;Trusted_Connection=True;
C:\Program Files\Microsoft SQL Server\140\Setup Bootstrap\Log\20190413_094229
d:\SQLServer2017Media\Express_CHS
C:\Program Files\Microsoft SQL Server\140\SSEI\Resources


数据库必须有一个主要数据文件，可有多个次要数据文件，而且可以指定磁盘存储位置，防止主要数据文件受磁盘大小限制

字段类型：
文本 varchar()可变长单字节字符串，最长8000个字符  varchar(20)能存储20个字母或10个汉字
	nvarchar()可变长双字节字符串，最长4000个字符 ，解决汉子存储， nvarchar（20）能存20个汉字，或20个字母
	char() nchar()定长字符串
	text 最长2^32-1个字符
	
可以把多个字段设置成主键来约束，在表设计中，选中需要多列字段的右键选择设为主键即可

//表的备份
select col,col,col
int table_bak
from table

IDEA配置SQLServer
https://www.cnblogs.com/wayne-shen/p/3936740.html
配置Sa账户密码
https://jingyan.baidu.com/article/6766299787b69c54d51b84bb.html

使用本地image需要主要配置外部路径
https://blog.csdn.net/black_dreamer/article/details/51955841


utf-8只对post请求导致的乱码有效，get方法提交的无效
对于get方法，需要使用iso-8859-1来解码获取字节再使用utf-8编码
String name=new String(name.getByte("iso-8859-1"),"UTF-8);


pageContext 的生命周期只在jsp文件中
request生命周期可以通过forward从Servlet到jsp文件中
session的生命周期取决于客户端浏览器，存活在打开的任何jsp文件中
application的生命周期和Tomcat一样，是全局的

jsp标准动作,如果不指定scope，默认是作用域最小的pageContext
<jsp:useBean id="doctor" class="com.nanj.locker.entity.Doctor" scope="request"/>
Doctor doctor=request.getAttribute("doctor")
if(doctor==null){
	doctor=new Doctor();
	request.setAttribute("doctor",doctor);
}


//-------------Spring
https://start.spring.io/  初始化项目
https://maven.apache.org/download.cgi 下载maven
https://www.cnblogs.com/eagle6688/p/7838224.html maven环境变量的配置

pox.xml中的spring boot maven plugin为我们打包一个可执行的jar包
打包命令：mvn clean package -Dmaven.test.skip
作为一个进程直接运行 ：java -jar hello-spring-0.0.1-SNAPSHOT.jar


在resources/application.properties文件中添加，
management.endpoints.web.exposure.include=*
解禁所有endpoint，但这样曝露太多，有危险
使用management.endpoints.web.exposure.include=health,beans用来显示bean，和health
方法如下：
http://localhost:8080/actuator/beans等

如果编译出现bean找不到的情况，很有可能是依赖出现冲突，删除不需要的jar

解决Lombok注解不起作用
https://blog.csdn.net/m0_37779977/article/details/79028299


jdbc的错误码
org.springframework.jdbc.support下的sql-error-code.xml记录了所有数据库的错误码类型

自定义错误类型 
1.将sql-error-code.xml文件复制到resource目录下，
2.在需要的数据库下添加如下内容：自定义重复主键异常
<property name="customTranslations">
			<bean class="org.springframework.jdbc.support.CustomSQLErrorCodesTranslation">
				<property name="errorCodes" value="23001,23505" />
				<property name="exceptionClass"
						  value="com.example.data.hellospring.CustomDuplicateException" />
			</bean>
		</property>
3.CustomDuplicateException需要继承DuplicateKeyException

使用数据库中间件来做分库分表
TDDL、Cobar、MyCAT、Sharding-Shpere这些可以了解一下，尤其是后面两个

阿里巴巴的Druid日志监控

JPA的使用 Hibernate
https://docs.spring.io/spring-data/jpa/docs/2.1.5.RELEASE/reference/html/







//window下 Docker下载安装
如果Docker安装不了，只能先下载ToolBox，https://docs.docker.com/toolbox/overview/
安装https://docs.docker.com/toolbox/toolbox_install_windows/

docker的默认地址为192.168.99.100：2376，如果本地没有配置对应的ip端地址和掩码将访问出错：
error during connect: Get https://192.168.99.100:2376/v1.37/containers/json: dial tcp 192.168.99.100:2376: connectex: A connection attempt failed because the connected party did not properly respond after a period of time


安装mogoDB
Window下安装docker toolbox 的小伙伴看过来，如果你也启动mongodb 不成功请看下面：
1、下载：$docker pull mongo 
2、查看：$docker images （会看到自己下载的镜像）
3、去创建一个docker卷 ：$ docker volume create mongodata
4、查看一下你的卷路径（确保创建成功）：$ docker volume inspect mongodata
如果成功会出现以下内容：
[
    {
        "CreatedAt": "2019-02-28T09:12:08Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/mnt/sda1/var/lib/docker/volumes/mongodata/_data",
        "Name": "mongodata",
        "Options": {},
        "Scope": "local"
    }
]
5、这个时候就可以运行啦$ docker run --name mongo -p 27017:27017 -v mongodata:/data/db -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=root -d mongo

运行mongo：docker exec -it mongo bash
登陆：mongo -u root -p root
显示数据库：show dbs 


安装redis
1、下载：$docker pull redis
2.运行 docker run --name redis -d -p 6379:6379 redis 


1.进入redis：docker exec -it redis redis-cli
2.显示所有keys：keys *
3.获取keys：hgetall coffee_menu


1 使用xml的方式配置Bean和依赖注入
	构造方法实列化Bean
 <bean id="addService" class="com.example.mvc.IServiceImpl" init-method="init" destroy-method="destroy">
        <!--构造方法依赖注入-->
        <constructor-arg name="name" value="lxl"/>
        <constructor-arg name="level" value="13"/>
        <constructor-arg name="date"  ref="today"/>
        <!--Set 方法注入-->
        <property name="caculator" ref="cacu" />
        <!--复杂类型注入 必须有set方法-->
        <property name="items" >
            <list>
                <value>av</value>
                <value>asfdf</value>
            </list>
        </property>
    </bean>
    <!--使用静态工厂实列化Bean-->
    <bean id="addFactoryService" class="com.example.mvc.ServiceFactory" factory-method="getService"/>
    <!--使用实列工厂实列化Bean-->
     <bean id="instanceService" class="com.example.mvc.ServiceFactory"/>
     <bean id="addInstanceService" factory-bean="instanceService" factory-method="getInstance"/>
	 
	 
2.使用注解方式创建Bean对象
	@Component 作用于接口或类，相当于xml中的bean标签，其value相当于id属性，默认为类名并首字母小写
	由@Component衍生的下面三个注解，作用属性和Component一模一样
	@Controller 用于表现层
	@Service    用于业务层
	@Repository  用于持久层
	
	@Autowired 自动按照类型注入 只要有唯一匹配的类型就能注入成功，不需要set方法
				但如果配类型不唯一，就会以变量名作为id去容器查找对应对象，
	@Qulifier 在按照类型注入的基础上指定Bean对象的id，在成员变量上不能独立使用，给方法形参可以独立使用
	@Resource 直接按照bean的id注入，属性name=bean的id
	 
	 

3.改变对象作用域
@scope 属性value：取值范围和xml中定义的一样


@ComponentScan 相当于xml中的 <context:component-scan base-package="com.example.mvc"/>
@Configuration 指定类为bean配置类，里面带有@Bean注解的方法返回值才能加入到Spring容器中
@Bean将方法的返回值作为Bean加入Spring容器中，属性name用于指定id，不指定默认是方法名。只能用在方法上
@Import 导入其他Bean所在的类而又不会加载那个类到容器中
@PropertySource指定属性资源，用来在@Value中使用EL表达式获取
@Transactional 可用在接口、类、方法上
		用在接口上，所有实现类都有事务
		用在类上，类中所有方法都有事务
		用来方法上，方法有事务
		优先级，按就近原则

拉取MySQL镜像
docker pull mysql:5.6

第一次运行MySql：
docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 --restart=always  mysql:5.6
参数含义：
--name mysql  将容器命名为mysql，后面可以用这个name进行容器的启动暂停等操作
-e MYSQL_ROOT_PASSWORD=123456 设置MySQL密码为123456
-d 此容器在后台运行,并且返回容器的ID
-i 以交互模式运行容器
-p 进行端口映射，格式为主机(宿主)端口:容器端口
--restart=always 当docker重启时，该容器自动重启

非常重要docker-machine ip查看docker ip，要连接docker中数据库必须使用此IP地址


进入mysql：
docker exec -ti mysql bash
登陆指令：mysql -uroot -p123456  
创建数据库：create database lxl_spring;
或指定字符集：CREATE DATABASE javabase DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci;
1）CREATE  DATABASE  mydbname  CHARACTER SET  utf8  COLLATE utf8_general_ci；

2）CREATE  DATABASE  IF NOT  EXISTS  mydbname  DEFAULT CHARACTER SET utf8;

使用数据库：use  lxl_spring;
创建数据表
create table foo
(
    id   int primary key auto_increment,
    name varchar(64)
);
插入数据
insert into foo( name)
values ( 'one');

insert into foo( name)
values ( 'two');

create table user
(
    id       bigint(20) NOT NULL AUTO_INCREMENT,
    user_name varchar(100) default null comment '用户名',
    password  varchar(100) default null comment '密码',
   name      varchar(100) default null comment '姓名',
    primary key (id)
)engine=Innodb auto_increment=7 default charset=utf8;

insert into user( user_name, password, name) values ('zhangsan','123','张三');
insert into user( user_name, password, name) values ('lisi','123','李四');
insert into user values (9,'lisi','123','李四');


create table customer
(
    id       int(10) NOT NULL AUTO_INCREMENT,
    user_name varchar(32) default null comment '用户名',
    birthday  datetime default null comment '生日',
   sex      char(1) default null comment '性别',
   address      varchar(256) default null comment '地址',
    primary key (id)
)engine=Innodb  default charset=utf8;

insert into customer values(1,'张三','2019-02-04 14:45:36','男','南京雨花区');

和customer表有外键关联
create table account
(
    id       int(11) NOT NULL AUTO_INCREMENT,
    uid int(11) default null comment '用户id',
    money  double default null comment '账户余额',
    primary key (id),
    key  fk_reference_8 (uid),
    constraint fk_reference_8 foreign key (uid) references customer (id)
)engine=Innodb  default charset=utf8;



###Spring执行过程分析
- 1 Tomcat启动 加载web/xml 配置文件
- 2 实列化并初始化DispatchServlet
- 3 加载springmvc.xml配置文件，创建容器并初始化Bean
- 4 客户端请求
- 5 前端控制器DispatchServlet接收请求，调用doDispatch()
- 6 前端控制器DispatchServlet通过动作名称在@requestMapper查找Handler
- 7 调用处理器适配器处理handler得到ModelAndView：mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
- 8 试图渲染，将Model数据填充到View：view = resolveViewName(viewName, mv.getModelInternal(), locale, request); 再调用view的渲染方法将Model写入request域
- 9 方法有返回值，根据视图解析器InternalResourceViewResolver找到响应页面

处理器映射器RequestMappingHandlerMapping
处理设配器RequestMappingHandlerAdapter

@Controller注解的作用：对@RequestMapping注解进行映射
@RequestMapping：建立url和方法的对应关系，也可以用在类上表示根url

Get请求乱码问题在Tomcat的Server.xml文件中
 <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" 
               useBodyEncodeUrI="True"
               />
如果是Ajax的请求依然乱码将 useBodyEncodeUrI="True"改为 URIEncoding="UTF-8

post乱码在Spring中配置过滤器

创建用户授权指定数据库
CREATE USER 'java'@'localhost' IDENTIFIED BY 'password';
GRANT ALL ON javabase.* TO 'java'@'localhost' IDENTIFIED BY 'password';




# SpringBoot的自动配置
SpringBootApplication注解含有@EnableAutoConfiguration，它能自动帮你导入配置类
如果某个包下的类配置此注解，那么此包及子包都会被扫描，一般用在引导类上。
如果你不用在引导类上，也尽量用在根包下的某个类上，这样此包及子包都会被扫描

其导入了配置类AutoConfigurationImportSelector.java，其中方法
getCandidateConfigurations（。。，。。）从META-INF/spring.factories读取需要加载的类

比如：DataSourceAutoConfiguration
	@Configuration
    @Conditional({DataSourceAutoConfiguration.EmbeddedDatabaseCondition.class}) //需要匹配的条件
    @ConditionalOnMissingBean({DataSource.class, XADataSource.class})//在没有指定类的条件下
    @Import({EmbeddedDataSourceConfiguration.class})//导入配置类 完成嵌入型数据的配置
    protected static class EmbeddedDatabaseConfiguration {
        protected EmbeddedDatabaseConfiguration() {
        }
    }


在EditConfiguration中配置运行参数，在Configuation选项下的Envirement中设置program argument为 --debug
程序启动后就能打印出各种成功或失败的配置结果：匹配的，不匹配的，无条件的等等

在终端使用 mvn dependency:tree 命令显示依赖书


SpringBootStart- 启动依赖会帮我们管理所启动所需呀的依赖，点击artifactId查看pom文件
配置属性源，这样使用    @Value("${driver}")可以直接注入
@PropertySource("classpath:jdbc.properties")

查看设置，比如仓库的位置
mvn help:effective-settings




