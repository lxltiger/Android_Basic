1.ArrayList
	构造函数 无参的默认capacity=10，elementData数组指向DEFAULTCAPACITY_EMPTY_ELEMENTDATA
			指定capacity，按capacity初始化elementData数组，如果capacity=0，elementData数组指向EMPTY_ELEMENTDATA
			使用Collection初始化，复制Collection的元素到elementData数组

	1.1添加，以添加到指定位置为例
	public void add(int index, E element) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    	//添加之前保证数组的容量是足够的 私有方法，内部使用
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //把index之后的元素都往后移一位，由于数组的内存都是事先分配好的，是连续的，所以可以使用System.arraycopy整块移动，这样的效率是极高的。如果scr和des是同一个数组，会先复制到临时内存再复制到指定位置
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }

    //minCapacity=元素的size+插入的元素数量
    private void ensureCapacityInternal(int minCapacity) {
    	//如前面所述如果是无参的构造函数，elementData =DEFAULTCAPACITY_EMPTY_ELEMENTDATA，所以第一次添加元素时会设置minCapacity=DEFAULT_CAPACITY=10
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        ensureExplicitCapacity(minCapacity);
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        // overflow-conscious code
        //minCapacity表示数组需要容纳的最小个数，如果比数组当前容量还大就需要扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }

     private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        //扩容的策略是增加一半容量，注意位运算加了括号，其优先级比加号低
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        //如果增加一般容量还达不到最低要求，就按最低要求来
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
            //容量超过20亿的情况还没遇到过
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        //元素迁移到扩容后的新数组 用的是native方法System.arraycopy 效率高，估计是直接复制内存块
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    如果你添加到ArrayList中的元素个数是确定的，最好在构造方法指定capacity，如果之后想手动扩容，可以使用ensureCapacity一步到位，避免数组扩容过程中的反复复制
    public void ensureCapacity(int minCapacity) {
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It's already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;

        if (minCapacity > minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }
    1.2 添加集合到指定位置，可以添加集合自己，但添加的仅是元素的引用，元素不会另复制
     public boolean addAll(int index, Collection<? extends E> c) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        //numMoved==0说明加载末尾，此时不需要操作，否则从index开始，numMoved长度的元素要移动到其实位置为index + numNew出，给要插入的数组腾出空间
        if (numMoved > 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
        //将集合元素复制到指定位置
        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

    1.3 移除 单个移除比较简单，支持null值删除，批量删除 重点看batchRemove，
    //批量删除有两个含义，一个是把包含在集合c中的元素删除，一个是把包含在集合c中元素保留，否则删除，所以使用complement作为补充说明
    private boolean batchRemove(Collection<?> c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r < size; r++)
            	//从头遍历，把符合条件的依此移动覆盖到数组前面
            	我们并没有遇到一个符合条件的就处理，而是把符合条件的集中起来，
            	
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            //如果r！=size 说明在c.contains()抛出了异常，遍历没有走完
            //这样的话把没有走完的元素，从r开始，到size，长度为size-r，复制到以w开始的地方
            if (r != size) {
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
            //w是要保留的数据数量，从数组0开始到w-1，如果和size一样大，说明什么都没动
            //否则把从w开始的元素都置为空，即删除掉了
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i < size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }
    1.8还支持条件删除，基本思想和批量删除一样，把需要保留的移动到数组左边，剩下的集中处理
    public boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        // figure out which elements are to be removed
        // any exception thrown from the filter predicate at this stage
        // will leave the collection unmodified
        int removeCount = 0;
        //使用位来标记需要删除的，可极大的节省内存，否则使用一个int类型来标记需要32位
        //当集合元素极大时，才能看出差距，但这种方式内部很复杂 涉及复杂的位运算
        final BitSet removeSet = new BitSet(size);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            @SuppressWarnings("unchecked")
            final E element = (E) elementData[i];
            if (filter.test(element)) {
            	//会将和i对应的位标为true 即是要删除的，也是不需要移动了
                removeSet.set(i);
                removeCount++;
            }
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

        // shift surviving elements left over the spaces left by removed elements
        final boolean anyToRemove = removeCount > 0;
        if (anyToRemove) {
        	//这里的逻辑就和批量删除一致，将需要保留的元素移动到左侧
            final int newSize = size - removeCount;
            //这个循环主要通过j控制，当要移动的元素都移完就退出循环
            for (int i=0, j=0; (i < size) && (j < newSize); i++, j++) {
            	//找到下一个需要移动的元素，
                i = removeSet.nextClearBit(i);
                //找到合适的位置复制过去，会覆盖那些要删除，但我们不在乎 省了手动置空
                elementData[j] = elementData[i];
            }
            //需要保留的都移到newSize之前了，从newSize开始都是需要删除的
            for (int k=newSize; k < size; k++) {
                elementData[k] = null;  // Let gc do its work
            }
            this.size = newSize;
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            modCount++;
        }

        return anyToRemove;
    }

    1.3迭代器 Iterator 只能往后遍历，ListIterator前后都能遍历，
    1.4 SubList 操作ArrayList指定的区间，增删改的方法还是ArrayList提供的 遍历的方法是自己的复写的
    1.5 并发流 未分析
    1.6 clone 克隆后的集合是新对象，但里面的元素和原来的一样，是浅拷贝
